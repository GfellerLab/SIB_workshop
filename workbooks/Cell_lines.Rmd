---
title: "Cell Lines"
subtitle: "Simplification of a simple scRNA-seq dataset of 5 cancer cell lines from (Tian et al., 2019)[https://doi.org/10.1038/s41592-019-0425-8]"
author: "Mariia Bilous, Aurelie Gabriel, Leonard Herault and David Gfeller"
output:
  md_document:
    toc: true # table of content true



---

# Suggested course structute:
We first run a **standard scRNA-seq data analysis pipeline** (i.e., data normalization, feature selection, dimensionality reduction, visualization, clustering and differential expression analysis) using the [Seurat](https://satijalab.org/seurat/index.html) framework. Then, we **simplify** the same dataset by computing *metacells* (i.e., grouping transcriptionally highly similar single cells into metacells). For this, we will use a method developed in our group called [SuperCell](https://github.com/GfellerLab/SuperCell). We will also provide some hints on how *metacells* can be computed using alternative approaches including [MetaCell](https://github.com/tanaylab/metacell), [Metacell-2](https://metacells.readthedocs.io/en/latest/readme.html), and [SEACell](https://github.com/dpeerlab/SEACells). We will then run **'a standard scRNA-seq data analysis pipeline'** adjusted to the metacell data and compare the results obtained at the single-cell and the metacell levels. 

Then, the participant can use the code we provide to build metacells and run some basic analysis for their datasets 

***
**Some options:**

* Alternatively, we can run an adjusted (ie., sample-weighted) pipeline for metacells or/and a standard (ie, Seurat).

* Subsampling at the same graining level -> compare the results to those obtained at the single-cell level

* We could provide an example of how metacell can be used for RNA-velocity (on another dataset)

* How metacells can be used for data integration (if we have nice examples)

* when and if analyzing their own data, make sure to introduce `cell.annotation` and `cell.split.condition` arguments of `SCimplify()` to avoid mixing of annotated cell types / conditions  within metacells. 

***

# TO DO:

* ~~make `supercell_DimPlot()`~~ push `supercell_DimPlot()`
* match colors for cell lines and clusters
* write 'standard (not sample-weighted)' analysis on metacells

* code for MC2 and SEAcells computation (to provide a link), save and provide results of metcell membership computed with MC2 and SEACell 

* dataset for demo of gene-gene correlation/RNA velocity/ Data integratoin for more advanced steps of the analysis 
* ATAC-seq example ?

```{r Load libraries, message=FALSE, warning=FALSE}
# make a data library (cell lines or Zilionis)
library(SuperCell)
library(Seurat)
library(dplyr)
```

```{r Load data}
proj.name    <- 'cell_lines'
.color.cell.type <- c("A549" = "#E69F00", "H838" = "#56B4E9", "H1975" = "#009E73", "H2228" = "#F0E442", "HCC827" = "#CC79A7")
data.folder  <- file.path("..", "data", proj.name)

# load single-cell (sc) count matrix and cell metadata 
sc.counts <- readRDS(file.path(data.folder, "sc_counts_filtered.Rds"))
sc.meta   <- readRDS(file.path(data.folder, "sc_meta_filtered.Rds"))

# Make sure metadata and count matrix have the same cells in the same order
if(!identical(rownames(sc.meta), colnames(sc.counts))){
  stop("Metadata (`sc.meta`) does not correspond to the count matrix (`sc.counts`)")
}
```

# Single-cell level
## Standard downstream analysis  
Run a brief analysis at the single-cell level, lets's use the common [Seurat](https://satijalab.org/seurat/index.html) pipeline

<span style="color: green;"> depending on the participants' experience with Seurat, we can either separately run these steps of the pre-processing or 'skip it' with 'one-line' command. For the moment, it is more step-by -step pre-processing, that can be replaced with : </span> 
`sc <-  NormalizeData(sc, verbose=FALSE) %>% FindVariableFeatures(selection.method = "disp", nfeatures = 1000, verbose=FALSE) %>% ScaleData(verbose=FALSE) %>% RunPCA(verbose=FALSE)`

```{r}
set.seed(12345)
sc <- CreateSeuratObject(counts = sc.counts, project = proj.name, meta.data = sc.meta)
sc
```

### Pre-processing
#### Data normalization
```{r Normalize data and compute a set of highly variable genes, message=FALSE, warning=FALSE}
sc <- NormalizeData(sc, verbose=FALSE)

sc <- FindVariableFeatures(
  sc, 
  selection.method = "disp", # "vst" is default
  nfeatures = 1000,
  verbose=FALSE
  )

hvg <- VariableFeatures(sc, verbose=FALSE)

# Plot variable features 
plot1 <- VariableFeaturePlot(sc)
LabelPoints(plot = plot1, points = hvg[1:20], repel = TRUE)
```

#### Scaling and dimensionality redution
```{r message=FALSE, warning=FALSE}
sc <- ScaleData(sc, verbose=FALSE)
sc <- RunPCA(sc, verbose=FALSE)

# Plot PCA (2D representation of scRNA-seq data) colored by cell line
DimPlot(sc, reduction = "pca", group.by = "cell_line", cols = .color.cell.type)
```

### UMAP (non-linear dimensionality reduction)
```{r UMAP, message=FALSE, warning=FALSE}
sc <- RunUMAP(sc,  dims = 1:10)

# Plot UMAP (2D representation of scRNA-seq data) colored by cell line
DimPlot(sc, reduction = "umap", group.by = "cell_line", cols = .color.cell.type)
```

### Clustering
```{r message=FALSE, warning=FALSE}

sc <- FindNeighbors(sc, dims = 1:10)
sc <- FindClusters(sc, resolution = 0.05)

# As it is a toy example with well defined cell types (i.e., cell lines), unsupervised clustering fully recapitulates cell line annotation 
table(sc@active.ident, sc$cell_line)
DimPlot(sc, reduction = "umap", group.by = "ident")

```

### Differential expression analysis 
#### Find Markers of cell lines
```{r message=FALSE, warning=FALSE}
# Set idents to cell lines (as clusters are the same as cell lines)
Idents(sc) <- "cell_line"

# Compute upregulated genes in each cell line (versus other cells)
sc.all.markers <-  FindAllMarkers(sc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = "t")
saveRDS(sc.all.markers, file = file.path(data.folder, "output", "sc_all_markers.Rds"))

# Load markers (backup)
#sc.all.markers <- readRDS(file = file.path(data.folder, "output", "sc_all_markers.Rds"))

# Top markers (select top markers of each cell line)
sc.top.markers <- sc.all.markers %>%
   group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)

sc.top.markers
```

#### Plot the expression of some found markers 
```{r fig.height=5, fig.width=9}
VlnPlot(sc, features = sc.top.markers$gene[c(seq(1, 9, 2), seq(2, 10, 2))], ncol = 5, pt.size = 0.0, cols = .color.cell.type)
```


# Data simplification (coarse-graining) -- Construction of *metacells*

Here we compute metacells using our method called [SuperCell](https://github.com/GfellerLab/SuperCell), but equally, metacells can be computed with [Metacell](https://github.com/tanaylab/metacell), [Metacell2.0](https://metacells.readthedocs.io/en/latest/readme.html) or [SEACell](https://github.com/dpeerlab/SEACells) algorithms and we will see some examples below.
```{r Set parameters}
gamma <- 20 # Graining level

# Compute metacells using SuperCell package
MC <- SCimplify(
  X = GetAssayData(sc), # single-cell log-normalized gene expression data
  genes.use = hvg, 
  gamma = gamma,
  n.pc = 10
)

# Compute gene expression of metacells by simply averaging gene expression within each metacell
MC.ge <- supercell_GE(
  ge = GetAssayData(sc),
  groups = MC$membership
)

# Alternatively, counts can be averaged (summed up) followed by a lognormalization step (this approach is used in the MetaCell and SEACell algorithms)
if(0){
  MC.counts <- supercell_GE(
    ge = GetAssayData(sc, slot = "counts"),
    mode = "sum", # summing counts instead of the default averaging
    groups = MC$membership
  )
  
  MC.ge <- Seurat::LogNormalize(MC.counts, verbose = FALSE)
}
```

## Downstream analysis of metacells
There are two options to perform the downstream analysis: 

* **sample-weighted** when we account for a metacell size at each etep of the analysis 
* **standard** when we treat metacells as single-cell and apply a standard pipeline

## Sample-weighted downstream analysis of *metacells*

For the sample-weighted analysis, we use a pipeline avalable with our [SuperCell]() package.

### Pre-processing

#### Transfer metadata (annotate metacell to a certain cell line)
Since the cell line information is available in this dataset, we can annotate metacells to a certain cell line. Each metacell is annotated to the most abundant cell type in it.
This also allows us to compute metacell *purity*, that is defined as a proportion of the most abundant cell type (use `method = "max_proportion"`) or as Shannon entropy (use `method = "entropy"`).

```{r metacell annotation to cell line and their purity}
# Annotate metacells to cells line
MC$cell_line <- supercell_assign(
  cluster = sc.meta$cell_line,          # single-cell assignment to cell lines 
  supercell_membership = MC$membership,  # single-cell assignment to metacells
  method = "absolute" # available methods are c("jaccard", "relative", "absolute"), function's help() for explanation
)

# Compute purity of metacells as :
#  * a proportion of the most abundant cell type withing metacells (`method = `"max_proportion)
#  * an entropy of cell type within metacells (`method = "entropy"`)
method_purity <- c("max_proportion", "entropy")[1]
MC$purity <- supercell_purity(
  clusters = sc.meta$cell_line,
  supercell_membership = MC$membership, 
  method = method_purity
)

# Metacell purity distribution
summary(MC$purity)
#hist(MC$purity, main = paste0("Purity of metacells \nin terms of cell line composition (", method_purity,")"))
```
#### Visualize data using  metcall network 
```{r metacell plot metacell network color cell line}
supercell_plot(
  MC$graph.supercells, 
  group = MC$cell_line, 
  color.use = .color.cell.type,
  seed = 1, 
  alpha = -pi/2,
  main  = "Metacells colored by cell line assignment"
)
```
#### Create Seurat object to perform standard downstream analysis 
```{r}
MC.seurat <- supercell_2_Seurat(
  SC.GE = MC.ge, 
  SC = MC, 
  fields = c("cell_line", "purity"),
  var.genes = MC$genes.use,
  N.comp = 10
)

Idents(MC.seurat) <- "cell_line"

MC.seurat <- RunUMAP(MC.seurat, dims =1:10)
DimPlot(MC.seurat, cols = .color.cell.type, reduction = "umap")
```


#### Dimensionality reduction (sample-weighted PCA +  UMAP)
```{r metacell PCA}
MC$PCA <- supercell_prcomp(
  Matrix::t(MC.ge),
  genes.use = MC$genes.use,  # or a new set of HVG can be computed
  supercell_size = MC$supercell_size, # provide this parameter to run sample-weighted version of PCA,
  k = 10
)

MC$UMAP <- supercell_UMAP(
  SC = MC,
  PCA_name = "PCA",
  n_neighbors = 30 # large number to repel cells 
)

supercell_DimPlot(
  MC, 
  groups = MC$cell_line,
  dim.name = "UMAP", 
  title = paste0("UMAP of metacells colored by cell line assignment"),
  color.use = .color.cell.type
)

```

#### Clustering (sample-weighted hclust)

Sample-weighted clustering computed with the hierarchical clustering, that may accounts for sample weights
```{r metacell clustering}
## compute distance
D                <- dist(MC$PCA$x)

## cluster metacells
MC$clustering    <- supercell_cluster(D = D, k = 5, supercell_size = MC$supercell_size)

# Plot clustering result
supercell_DimPlot(
  MC, 
  groups = factor(MC$clustering$clustering),
  dim.name = "PCA", 
  title = paste0("PCA of metacells colored by metacell clustering")
)
```
```{r Consistency between clustering and cell line assignment }
table(MC$cell_line, MC$clustering$clustering)
```
### Differential expression analysis in metacells
```{r DEA metacells}
# Compute upregulated genes in each cell line (versus other cells)
MC.all.markers <- supercell_FindAllMarkers(
  ge = MC.ge, 
  clusters = MC$cell_line, 
  supercell_size = MC$supercell_size,
  only.pos = TRUE, 
  min.pct = 0.25, 
  logfc.threshold = 0.25
)

saveRDS(MC.all.markers, file = file.path(data.folder, "output",  paste0("MC_gamma_", gamma, "_all_markers.Rds")))

# Load markers (backup)
#MC.all.markers <- readRDS(file = file.path(data.folder, "output", "paste0("MC_gamma_", gamma, "_all_markers.Rds")))

MC.all.markers.df <- data.frame()
for(cl in names(MC.all.markers)){
  cur <- MC.all.markers[[cl]]
  cur$cluster <- cl
  cur$gene <- rownames(cur)
  cur$avg_log2FC <- cur$logFC
  MC.all.markers.df <- rbind(MC.all.markers.df, cur)
}


# Top markers (select top markers of each cell line)
MC.top.markers <- MC.all.markers.df %>%
   group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)

```
#### Plot the expression of some found markers (in metacells)
```{r fig.height=5, fig.width=9}

supercell_VlnPlot(
  ge = MC.ge, 
  supercell_size =MC$supercell_size, 
  clusters = MC$cell_line,
  features = MC.top.markers$gene[c(seq(1, 9, 2), seq(2, 10, 2))],
  ncol = 5)

```


## Standard downstream analysis
For the standard downstream analysis, we can use the well-established [Seurat](https://satijalab.org/seurat/index.html) pipeline
```{r}

```

## Alternative constructions of metacells
### Metacell construction with [Metacell-2](https://metacells.readthedocs.io/en/latest/Metacells_Vignette.html)

Load pre-computed metacells with the Metacell-2 approach. See this [workbook](https://github.com/GfellerLab/SIB_workshop/blob/main/workbooks/Metacell2.ipynb) to reproduce the results or to run your own Metacell2 construction.
```{r}
library(anndata)
## Load pre-computed metacell partition obtained with Metacell-2

### comment this and provide R object dirrectly in case anndata will rise errors 
metacell2_adata  <- read_h5ad(file.path(data.folder, "output", "seacells_gamma_20.h5ad")) # Metacell as anndata object
metacell2_adata  <- read_h5ad(file.path(data.folder, "output", "mc2_gamma_20.h5ad")) # Metacell as anndata object
metacell2_adata  <- read_h5ad(file.path(data.folder, "output", "metacell2_gamma_20.h5ad")) # Metacell as anndata object
obs.sc           <- metacell2_adata #read.csv(file.path(data.folder, "output", "metacell2_20.csv")) # obs (cell meta data) of single-cell data used to build metacells with Metacell2

metacell2 <- metacell_anndata_2_supercell(adata, obs.sc)

# Annotate metacells to cell lines
metacell2$SC_cell_line <- supercell_assign(
  sc.meta$cell_line, 
  supercell_membership = metacell2$membership
)

# Metacell count matrix (yet to be log-normalized)
metacell2$SC.counts

metacell2$SC.meta$supercell_size <- metacell2$supercell_size

### END comment this and provide R object dirrectly in case anndata will rise errors 

mc.MC.seurat <- CreateSeuratObject(
  counts = metacell2$SC.counts, 
  project = paste0(proj.name, "_metacell2"), 
  meta.data = metacell2$SC.meta
)
```


