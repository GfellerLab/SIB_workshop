---
title: "Cell Lines"
subtitle: "Simplification of a simple scRNA-seq dataset of 5 cancer cell lines from (Tian et al., 2019)[https://doi.org/10.1038/s41592-019-0425-8]"
author: "Mariia Bilous, Aurelie Gabriel, Leonard Herault and David Gfeller"
output: html_notebook
---

# Suggested course structute:
We firtstly run a **standard scRNA-seq data analysis pipeline** (i.e., data normalizatoion, feature selection, dimensionality reduction, visualization, clustering and differential expression analysis) usign [Seurat](https://satijalab.org/seurat/index.html) framework. Then, we **simplify** the same dataset by computing *metacells* (i.e., grouping transcriptionally highly simiar sigle cells into metacells). For this we will use a method developed in our group called [SuperCell](https://github.com/GfellerLab/SuperCell). We will also provide some hints on how *metacells* can be coumputed using alternative approaches including [MetaCell](https://github.com/tanaylab/metacell), [Metacell2.0](https://metacells.readthedocs.io/en/latest/readme.html), and [SEACell](https://github.com/dpeerlab/SEACells). We will then run **'a standard scRNA-seq data analysis pipeline'** adjusted to the metacell data and compare the results ontained at the single-cell and the metacell levels. 

Then, they can use the code we provide to build metacells for their own datasets 

***
**Some options:**
* Alternatiely, we can run an adjusted (ie., sample-weighted) pipeline for metacells or/and a standard (ie, Seurat).
* Subsampling at the same graining level -> compare the results to those obtained at the single-cell level

* We could provide an example of how metacell can be used for RNA-velocity (on another dataset)
* How metacells can be used for data integration (if we have nice examples)

* when and if analysing their own data, make sure to intoduce `cell.annotation` and `cell.split.condition` arguments of `SCimplify()` to avoid mixing of annotated cell types / conditions  within metacells. 

***

```{r Load libraries, message=FALSE, warning=FALSE}
# make a data library (cell lines or Zilionis)
library(SuperCell)
library(Seurat)
library(dplyr)
```

```{r Load data}
proj.name    <- 'cell_lines'
data.folder  <- file.path("..", "data", proj.name)

# load single-cell (sc) count matrix and cell metadata 
sc.counts <- readRDS(file.path(data.folder, "sc_counts_filtered.Rds"))
sc.meta   <- readRDS(file.path(data.folder, "sc_meta_filtered.Rds"))

# Make sure metadata and count matrix have the same cells in the same order
if(!identical(rownames(sc.meta), colnames(sc.counts))){
  stop("Metadata (`sc.meta`) does not correspond to the count matrix (`sc.counts`)")
}
```

# Single-cell level
## Standard downstream analysis  
Run a brief analysis at the single-cell level, lets use the common [Seurat](https://satijalab.org/seurat/index.html) pipeline
<span style="color: green;"> depending on the audience experience with Seurat, we can either separetely run these steps of the pre-processing or 'skip it' with 'one-line' command. For the memont, it is more step-by -step pre-processing, that can be replaced with : </span> 
`sc <-  NormalizeData(sc) %>% FindVariableFeatures(selection.method = "disp", nfeatures = 1000, verbose=FALSE) %>% ScaleData(verbose=FALSE) %>% RunPCA(verbose=FALSE)`

```{r}
set.seed(12345)
sc <- CreateSeuratObject(counts = sc.counts, project = proj.name, meta.data = sc.meta)
sc
```

## Data normalization
```{r Normalize data and compute a set of highly variable genes}
sc <- NormalizeData(sc)

sc <- FindVariableFeatures(
  sc, 
  selection.method = "disp", # ""
  nfeatures = 1000
  )

hvg <- VariableFeatures(sc)
# plot variable features 
LabelPoints(plot = plot1, points = hvg[1:20], repel = TRUE)
```

## Scaling and dimensionality redution
```{r}
sc <- ScaleData(sc)
sc <- RunPCA(sc)

# Plot PCA (2D representation of scRNA-seq data) colored by cell line
DimPlot(sc, reduction = "pca", group.by = "cell_line")
```

## UMAP (non-linear dimensionaloty reduction)
```{r}
sc <- RunUMAP(sc,  dims = 1:10)

# Plot UMAP (2D representation of scRNA-seq data) colored by cell line
DimPlot(sc, reduction = "umap", group.by = "cell_line")
```

## Clustering single-cell data
```{r}

sc <- FindNeighbors(sc, dims = 1:10)
sc <- FindClusters(sc, resolution = 0.05)

# As it is a toy example with well defined cell types (i.e., cell lines), unsupervised clustering fully recapitulates cell line annotation 
table(sc@active.ident, sc$cell_line)
DimPlot(sc, reduction = "umap", group.by = "ident")

```
## Find markers of cell lines 
```{r}
# Set idents to cell lines (as clusters are the same as cell lines)
Idents(sc) <- "cell_line"

# Compute upregulated genes in each cell line (versus other cells)
sc.all.markers <-  FindAllMarkers(sc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25, test.use = "t")

saveRDS(sc.all.markers, file = file.path(data.folder, "output", "sc_all_markers.Rds"))

# Load markers (backup)
# sc.all.markers <- readRDS(file = file.path(data.folder, "output", "sc_all_markers.Rds"))

# Top markers (select top markers of each cell line)
sc.top.markers <- sc.all.markers %>%
   group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)

sc.top.markers
```
## Plot the expression of found markers 
```{r fig.height=2.5, fig.width=6}
VlnPlot(sc, features = sc.top.markers$gene[c(seq(1, 9, 2), seq(2, 10, 2))], ncol = 5, pt.size = 0.0)
```

# Data simplification (coarse-graining)

Here we compute metacells using our method called (SuperCell)[https://github.com/GfellerLab/SuperCell], but equally, metacells can be computed with (Metacell)[https://github.com/tanaylab/metacell], (Metacell2.0)[https://metacells.readthedocs.io/en/latest/readme.html] or (SEACell)[https://github.com/dpeerlab/SEACells] algorithms and we will see some examples below.
```{r Set parameters}
gamma <- 20 # Graining level

# Compute metacells using SuperCell package
MC <- SCimplify(
  X = GetAssayData(sc), # single-cell log-normalized gene expression data
  genes.use = hvg, 
  gamma = gamma,
  n.pc = 10
)

# Compute gene expression of metacells by simply averaging gene expression within each metacell

MC.ge <- supercell_GE(
  ge = GetAssayData(sc),
  groups = MC$membership
)

# Alternatively, counts can be averaged (summed up) followed by a lognormalization step (this approach is used in the MetaCell and SEACell algorithms)
if(0){
  MC.counts <- supercell_GE(
    ge = GetAssayData(sc, slot = "counts"),
    groups = MC$membership
  )
  
  MC.ge <- scater::normalizeCounts(MC.counts, size.factor = 1e4)
}
```

Alternatively, metacells can be computed using (Metacell)[https://github.com/tanaylab/metacell], (Metacell2.0)[https://metacells.readthedocs.io/en/latest/readme.html] or (SEACell)[https://github.com/dpeerlab/SEACells] algorithms. 


